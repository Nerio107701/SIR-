"""
HEAT MAPS for SIR outcomes vs (beta, gamma)
Run: python heatmap_sir.py
This script:
1) Defines SIR(β, γ) using odeint (same style as your code)
2) Sweeps a grid of (β, γ)
3) Computes three outcomes: peak I, time to peak, final size (R at T end)
4) Plots three HEAT MAPS (filled color) with an R0=1 overlay (β = γ)
"""

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

# -----------------------------
# Model + baseline parameters
# -----------------------------
N = 10_000          # total population
I0, R0 = 4, 0       # initial infected & recovered
S0 = N - I0 - R0    # initial susceptible
y0 = (S0, I0, R0)   # initial state vector

# Time grid (days). Choose long enough that I decays near zero by the end.
t = np.linspace(0, 160, 160)

def deriv(y, t, N, beta, gamma):
    """
    Right-hand side of the SIR ODEs.
    y = (S, I, R)
    beta: infection rate (per day)
    gamma: recovery rate (per day)
    """
    S, I, R = y
    dSdt = -beta * S * I / N
    dIdt = beta * S * I / N - gamma * I
    dRdt = gamma * I
    return dSdt, dIdt, dRdt

# ------------------------------------------
# Parameter sweep ranges for (beta, gamma)
# Keep units consistent (per day)
# ------------------------------------------
beta_vals  = np.linspace(0.05, 1.2, 60)  # x-axis
gamma_vals = np.linspace(0.05, 0.8, 60)  # y-axis

# Allocate 2D grids to store outcomes: shape = (len(gamma_vals), len(beta_vals))
peakI_grid  = np.zeros((len(gamma_vals), len(beta_vals)))  # maximum I(t)
tpeak_grid  = np.zeros_like(peakI_grid)                    # argmax time
Rfinal_grid = np.zeros_like(peakI_grid)                    # R(T_end)

# ------------------------------------------
# Core loop: solve SIR for each (β, γ)
# ------------------------------------------
for gi, gamma in enumerate(gamma_vals):
    for bi, beta in enumerate(beta_vals):
        # Integrate SIR with this parameter pair
        sol = odeint(deriv, y0, t, args=(N, beta, gamma))
        S, I, R = sol.T

        # Record metrics
        peakI_grid[gi, bi]  = I.max()         # peak infected (count)
        tpeak_grid[gi, bi]  = t[I.argmax()]   # time at which I is max
        Rfinal_grid[gi, bi] = R[-1]           # final recovered at end time

# Meshgrid for plotting and R0 computation
B, G = np.meshgrid(beta_vals, gamma_vals)  # B: β along x, G: γ along y
R0_grid = B / G

# -----------------------------
# Plotting: three heat maps
# -----------------------------
def add_common(ax, title, cbar, cbar_label):
    """Small helper to format axes identically."""
    ax.set_xlabel('β (per day)')
    ax.set_ylabel('γ (per day)')
    ax.set_title(title)
    # Overlay R0 = 1 (β = γ) as a dashed contour line
    ax.contour(B, G, R0_grid, levels=[1.0], linestyles='--', linewidths=2)
    # Colorbar label
    cbar.set_label(cbar_label)

# 1) Peak infected (fraction of population)
fig1, ax1 = plt.subplots(figsize=(7, 5))
h1 = ax1.contourf(B, G, peakI_grid / N, levels=20)  # heat map of peak fraction
cbar1 = fig1.colorbar(h1, ax=ax1)
add_common(ax1, 'Peak infected (fraction of N)', cbar1, 'Peak I / N')

# 2) Time to peak (days)
fig2, ax2 = plt.subplots(figsize=(7, 5))
h2 = ax2.contourf(B, G, tpeak_grid, levels=20)
cbar2 = fig2.colorbar(h2, ax=ax2)
add_common(ax2, 'Time of peak (days)', cbar2, 'days')

# 3) Final size = R(T_end)/N (attack rate)
fig3, ax3 = plt.subplots(figsize=(7, 5))
h3 = ax3.contourf(B, G, Rfinal_grid / N, levels=20)
cbar3 = fig3.colorbar(h3, ax=ax3)
add_common(ax3, 'Final size (R(T≈∞) / N)', cbar3, 'R / N')

plt.show()
